# softwaremaker-iterate

## 用途

当用户说「按需求迭代」「加个新功能 xxx」「新需求：xxx」或触发本 Command 时，**将用户提示词视为需求输入**，由 AI 接管并按公司软件开发的流程完成：需求澄清 → 方案设计 → 实现 → 自测与收尾。

适用场景：**已有项目（如 softwaremaker 建好的第一版）**，后续新增或修改功能，用户用自然语言描述需求，AI 按规范流程开发。

---

## 交互步骤（Agent 执行时遵循）

### 1. 需求澄清（必做）

- **解析用户提示词**：从当前对话或用户 @ 的上下文中提取需求描述（功能点、修改范围、约束）。
- **输出结构化需求**：用简短列表归纳「要做哪些事」（例如：新增接口、改前端页面、改 DB 等）。
- **可选确认**：若需求含糊或有多义，向用户提 1～2 个封闭式问题澄清，再进入下一步。

### 2. 方案设计（必做，先讨论后写代码）

- **技术方案**：针对当前代码库（可先快速浏览项目结构），给出：
  - 受影响模块（前端/后端/API/DB/配置等）
  - 接口或数据模型变更（如有）
  - 实现步骤与依赖关系
- **与用户确认**：把方案要点（可带 bullet 列表或简短说明）发给用户，**明确写「若同意该方案，我将按此实现」**，等用户同意后再进入实现阶段。
- 遵守用户规则：**先讨论方案，用户同意后才能开始写代码**。

### 3. 任务拆分与排期（内部执行）

- 将方案拆成可执行小任务（如：后端接口 → 前端调用 → 联调/自测）。
- 按依赖顺序执行，避免未定义接口就先写前端等。

### 4. 实现与规范

- **新建分支（必做）**：若项目已有 git，**必须先基于当前默认分支（如 main/master）创建新分支**再开发，例如 `feature/简短需求描述` 或 `feature/YYYYMMDD-需求简述`；禁止直接在 main/master 上改代码。
- **分支命名**：分支名需可读、与本次需求相关（如 `feature/user-login`、`feature/20250226-stock-list`），便于后续合并与回溯。
- **编码**：
  - 后端：符合项目既有风格与 Golang 惯例；新函数/包需有清晰注释（标准 Go 注释：函数名、参数、返回值、作用）。
  - 前端：符合项目既有风格与 React/TS 规范。
  - 无硬编码；命名与结构保持可读性。
- **文件与行数**：遵守用户规则（如 Go/Java 单文件 ≤250 行，Python/TS ≤200 行；单目录文件数控制）。

### 5. 自测与收尾

- **运行与验证**：能本地运行/联调的，给出**具体命令**让用户自己运行（遵守「能让我自己运行代码就直接给我运行命令」）。
- **清单**：实现完成后简要列出「已完成的修改点」和「建议你本地执行的命令」。
- **提交建议**：若用户需要，可给出 `git add` / `git commit` 建议信息，替用户执行 push。
- **打版本 tag（必做）**：每次迭代完成合并或修复/升级并提交后，在项目目录打版本 tag（如 `v1.0.1`、`v1.1.0`，建议语义化版本：修复用 patch、新功能用 minor、不兼容变更用 major），执行 `git tag <tagname>` 后 `git push origin <tagname>`；在结果反馈中写明本次 tag 名称与推送命令。

### 6. 测试流程（必做）

- **编写测试文档**：根据本次迭代涉及的功能与接口，编写前后端测试文档（用例、步骤、预期）。可派生子 agent 完成，使用 Task 工具，prompt 见 **子 agent：测试文档编写**（`.cursor/commands/softwaremaker-test-doc-agent.md`）。
- **后端测试文档**：覆盖本次新增/修改的 API 或服务，包含用例名、请求/步骤、预期响应或行为、通过标准。
- **前端测试文档**：覆盖本次新增/修改的页面或交互，包含用例名、操作步骤、预期结果；**前端测试执行时需截图**——在文档中明确标注「需截图」的步骤，并在执行前端测试时使用浏览器或 Playwright 对关键页面/状态截图，保存到项目约定目录（如 `docs/screenshots/` 或 `frontend/e2e/screenshots/`），在测试文档中引用截图路径。
- **执行与结果**：能自动跑的测试给出运行命令；需手测的列出清单。前端手测或 E2E 执行时按文档要求完成截图并写入文档。

### 7. 结果反馈

- 告诉用户：
  - 本次修改涉及的文件与模块
  - 如何本地启动/验证
  - 若有多处修改，简要说明「先做什么、后做什么」以便排查问题。
- 提醒：后续若还有新需求，可继续用同一流程（用户提示词 → 需求澄清 → 方案确认 → 实现）；测试文档与截图可随迭代累积在 `docs/` 或项目约定目录。

---

## 子 agent：测试文档编写

当需要编写前后端测试文档时，主 Agent 使用 **Task 工具** 派生子 agent，将以下说明作为 `prompt` 传入（可附上本次迭代的需求摘要、涉及接口与页面）：

- **子 agent 定义与 prompt 模板**：见 `.cursor/commands/softwaremaker-test-doc-agent.md`。主 Agent 读取该文件内容，填入本次迭代的上下文（项目路径、本次改动模块、接口列表、前端页面/组件列表），然后调用 `Task(subagent_type="generalPurpose", description="编写前后端测试文档", prompt=...)`。

---

## 使用约束

- **不替用户做未授权的破坏性操作**：如强制覆盖、删除未在方案中约定的文件；涉及删除或大范围重构时先说明并确认。
- **方案阶段不写代码**：仅在用户明确同意方案后开始写代码。
- **遵守用户关于端口、技术栈、权限等的显式约束**；不执行用户禁止的命令（如 kill/pkill）。
- 若需求超出当前项目技术栈或需要新依赖，在方案中说明并征得用户同意后再引入。
- **版本 tag**：每一次修复、升级或完成合并并提交后，必须打版本 tag（语义化版本：patch/minor/major），并推送到远程；在结果反馈中给出 tag 名与 `git push origin <tagname>` 说明。

---

## 调用工具 / 技能

在执行本 Command 时，Agent 按需调用以下技能完成子任务：

- **需求与方案**：`/brainstorming`、`/plan-writing`、`/architecture-patterns`（方案设计时）。
- **后端**：`/golang-pro`、`/backend-patterns`、`/api-design`；涉及 DB 时用 `/database`、`/database-migrations`。
- **前端**：`/frontend-dev-guidelines`、`/react-patterns`、`/frontend-patterns`。
- **质量与规范**：`/clean-code`、`/code-review-checklist`、`/lint-and-validate`。
- **测试与截图**：测试流程中派生子 agent 编写测试文档（prompt 见 `softwaremaker-test-doc-agent.md`）；前端测试需截图时使用 **cursor-ide-browser** MCP（`browser_navigate`、`browser_snapshot` 等）或 `/playwright-skill`、`/screenshots` 执行浏览器操作并保存截图。
- **运维与部署**：若涉及 Docker/部署，用 `/docker-expert`；涉及 CI 用 `/github-actions-templates` 等。
- **大块子任务**：需要批量重构或独立闭环开发时，可用 `/coding-agent` 在目标目录中执行，再由当前 Agent 做结果验证与收尾。

---

## 与 softwaremaker 的关系

- **softwaremaker**：从零创建前后端项目并推到 GitHub（第一版脚手架）。
- **softwaremaker-iterate**：在已有项目上，根据用户提示词（新需求/修改）按「需求澄清 → 方案确认 → 实现 → 自测与收尾」做迭代开发。

两者可配合使用：先用 softwaremaker 建仓，后续迭代用 softwaremaker-iterate。
